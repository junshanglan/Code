一、JVM相关
	1、内存模型：
		分为方法区、堆、虚拟机栈、本地方法栈和程序计数器
	2、JVM调优经验
		避免创建过大的对象及数组：过大的对象或数组在新生代没有足够空间容纳时会直接进入老年代，如果是短命的大对象，会提前出发Full GC。
		避免同时加载大量数据，如一次从数据库中取出大量数据，或者一次从Excel中读取大量记录，可以分批读取，用完尽快清空引用。
	3、常用的JVM参考参数
		-Xms	初始堆大小，默认物理内存的1/64	-Xms512M
		-Xmx	最大堆大小，默认物理内存的1/4	-Xms2G
		-Xmn	新生代内存大小，官方推荐为整个堆的3/8	-Xmn512M
		-Xss	线程堆栈大小，jdk1.5及之后默认1M，之前默认256k	-Xss512k
	4、垃圾回收算法
		1、判断哪些对象需要被回收
			引用计数法
			可达性分析算法
		2、标记-清除，标记-整理，复制算法，分代垃圾回收算法
			
二、IO流
三、SpringBoot
	
四、Redis
	1、数据的时效性
	2、保证数据的一致性
		①内存数据持久性
		②主从复制
		③分布式事务
	3、与Kafka使用的不同的场景
		Redis的设计理念是“数据结构存储”，它将多种数据结构（如字符串、哈希、列表、集合等）存储在内存中，并以键值对的形式进行管理。Redis主要用于缓存、队列等场景，支持高并发读写，读写速度快，但存储容量有限。
		kafka:分布式发布订阅消息系统。
		使用场景不同：
			Redis主要用于缓存、队列、计数器、排行榜等场景，因为数据读写速度快，适合处理高并发、实时性较高的业务场景。同时，Redis可以将数据存储在硬盘中，支持多节点同步复制，满足数据的可靠性要求。
			Kafka主要用于数据处理、消息队列等场景，它适合需要处理大量消息的场景，比如日志处理、数据流计算、实时分析等。Kafka支持分布式存储和处理，能够处理高并发请求，同时具有较好的容错性和稳定性。


五、并发编程
	1、volatail
		volatail是在多线程进行某一数据共享时需要使用的，它可以确保线程之间看到的同一共享数据相同，使得多线程在协作时不会出现操作覆盖。
		防止指令重排。
		synchronized：变量、方法、类级别，volatail是变量级别	
		
	2、TheadLocal
		如果多个线程同时竞争一把锁，这时会存在大量的锁等待，可能会浪费很多时间。
		空间换时间：共享变量在每个线程都有一个副本，每个线程操作的都是自己的副本，对其他线程没有影响。
六、内存模型
	1、分区
		虚拟机栈、本地方法栈、堆、常量池、程序计数器
	2、GC有几种
		Minor GC（新生代内存）、Full GC（整个堆内存进行回收，包括新生代和老年代。）

七、mybatis 与 mybatis plus
	mybatis plus : 
		便捷的操作和增强功能：MyBatis Plus封装了很多常用的数据库操作方法，如增删改查，使得开发者能够更快速地完成基本的数据库操作，减少了重复劳动。
		自动生成SQL语句：MyBatis Plus提供了代码生成器，可以根据实体类自动生成对应的SQL语句，简化了SQL语句的编写工作。
		条件构造器和分页功能：MyBatis Plus提供了条件构造器和分页插件，使得查询条件的构建和分页操作更加便捷。

1、平时周末会加班吗，还是根据项目的一个具体情况
2、评级比我预想的要低一些，试用期有调薪的机会吗？
3、绩效、定级调整机会
4、项目的介绍，业务以及整体
5、上班的时间，工作日上班时间